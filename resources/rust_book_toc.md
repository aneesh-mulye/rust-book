# Table of Contents — *The Rust Programming Language*

> Generated from the attached offline HTML build of the book.

- The Rust Programming Language
- Foreword
- Introduction
  - Who Rust Is For
    - Teams of Developers
    - Students
    - Companies
    - Open Source Developers
    - People Who Value Speed and Stability
  - Who This Book Is For
  - How to Use This Book
  - Source Code
- 1. Getting Started
  - 1.1. Installation
    - Command Line Notation
    - Installing rustup on Linux or macOS
    - Installing rustup on Windows
    - Troubleshooting
    - Updating and Uninstalling
    - Reading the Local Documentation
    - Using Text Editors and IDEs
    - Working Offline with This Book
  - 1.2. Hello, World!
    - Project Directory Setup
    - Rust Program Basics
    - The Anatomy of a Rust Program
    - Compilation and Execution
  - 1.3. Hello, Cargo!
    - Creating a Project with Cargo
    - Building and Running a Cargo Project
    - Building for Release
    - Leveraging Cargo’s Conventions
  - Summary
- 2. Programming a Guessing Game
  - Setting Up a New Project
  - Processing a Guess
    - Storing Values with Variables
    - Receiving User Input
    - Handling Potential Failure with Result
    - Printing Values with println! Placeholders
    - Testing the First Part
  - Generating a Secret Number
    - Increasing Functionality with a Crate
      - Ensuring Reproducible Builds
      - Updating a Crate to Get a New Version
    - Generating a Random Number
  - Comparing the Guess to the Secret Number
  - Allowing Multiple Guesses with Looping
    - Quitting After a Correct Guess
    - Handling Invalid Input
  - Summary
- 3. Common Programming Concepts
  - Keywords
  - 3.1. Variables and Mutability
    - Declaring Constants
    - Shadowing
  - 3.2. Data Types
    - Scalar Types
      - Integer Types
        - Integer Overflow
      - Floating-Point Types
      - Numeric Operations
      - The Boolean Type
      - The Character Type
    - Compound Types
      - The Tuple Type
      - The Array Type
      - Array Element Access
      - Invalid Array Element Access
  - 3.3. Functions
    - Parameters
    - Statements and Expressions
    - Functions with Return Values
  - 3.4. Comments
  - 3.5. Control Flow
    - if Expressions
      - Handling Multiple Conditions with else if
      - Using if in a let Statement
    - Repetition with Loops
      - Repeating Code with loop
      - Returning Values from Loops
      - Disambiguating with Loop Labels
      - Streamlining Conditional Loops with while
      - Looping Through a Collection with for
  - Summary
- 4. Understanding Ownership
  - What Is Ownership?
    - The Stack and the Heap
    - Ownership Rules
    - Variable Scope
    - The String Type
    - Memory and Allocation
      - Variables and Data Interacting with Move
      - Scope and Assignment
      - Variables and Data Interacting with Clone
      - Stack-Only Data: Copy
    - Ownership and Functions
    - Return Values and Scope
  - 4.2. References and Borrowing
    - Mutable References
    - Dangling References
    - The Rules of References
  - 4.3. The Slice Type
    - String Slices
      - String Literals as Slices
      - String Slices as Parameters
    - Other Slices
  - Summary
- 5. Using Structs to Structure Related Data
  - 5.1. Defining and Instantiating Structs
    - Using the Field Init Shorthand
    - Creating Instances with Struct Update Syntax
    - Creating Different Types with Tuple Structs
    - Defining Unit-Like Structs
    - Ownership of Struct Data
  - 5.2. An Example Program Using Structs
    - Refactoring with Tuples
    - Refactoring with Structs
    - Adding Functionality with Derived Traits
  - 5.3. Methods
    - Method Syntax
    - Where’s the -> Operator?
    - Methods with More Parameters
    - Associated Functions
    - Multiple impl Blocks
  - Summary
- 6. Enums and Pattern Matching
  - 6.1. Defining an Enum
    - Enum Values
    - The Option Enum
  - 6.2. The match Control Flow Construct
    - Patterns That Bind to Values
    - The Option<T> match Pattern
    - Matches Are Exhaustive
    - Catch-All Patterns and the _ Placeholder
  - 6.3. Concise Control Flow with if let and let...else
  - Staying on the “Happy Path” with let...else
  - Summary
- 7. Packages, Crates, and Modules
  - 7.1. Packages and Crates
  - 7.2. Control Scope and Privacy with Modules
    - Modules Cheat Sheet
    - Grouping Related Code in Modules
  - 7.3. Paths for Referring to an Item in the Module Tree
    - Exposing Paths with the pub Keyword
      - Best Practices for Packages with a Binary and a Library
    - Starting Relative Paths with super
    - Making Structs and Enums Public
  - Bringing Paths into Scope with the use Keyword
    - Creating Idiomatic use Paths
    - Providing New Names with the as Keyword
    - Re-exporting Names with pub use
    - Using External Packages
    - Using Nested Paths to Clean Up use Lists
    - Importing Items with the Glob Operator
  - 7.5. Separating Modules into Different Files
    - Alternate File Paths
  - Summary
- 8. Common Collections
  - 8.1. Storing Lists of Values with Vectors
    - Creating a New Vector
    - Updating a Vector
    - Reading Elements of Vectors
    - Iterating Over the Values in a Vector
    - Using an Enum to Store Multiple Types
    - Dropping a Vector Drops Its Elements
  - 8.2. Storing UTF-8 Encoded Text with Strings
    - Defining Strings
    - Creating a New String
    - Updating a String
      - Appending with push_str or push
      - Concatenating with + or format!
    - Indexing into Strings
      - Internal Representation
      - Bytes, Scalar Values, and Grapheme Clusters
    - Slicing Strings
    - Iterating Over Strings
    - Handling the Complexities of Strings
  - 8.3. Storing Keys with Associated Values in Hash Maps
    - Creating a New Hash Map
    - Accessing Values in a Hash Map
    - Managing Ownership in Hash Maps
    - Updating a Hash Map
      - Overwriting a Value
      - Adding a Key and Value Only If a Key Isn’t Present
      - Updating a Value Based on the Old Value
    - Hashing Functions
  - Summary
- 9. Error Handling
  - 9.1. Unrecoverable Errors with panic!
    - Unwinding the Stack or Aborting in Response to a Panic
  - 9.2. Recoverable Errors with Result
    - Matching on Different Errors
      - Alternatives to Using match with Result<T, E>
      - Shortcuts for Panic on Error
    - Propagating Errors
      - The ? Operator Shortcut
      - Where to Use the ? Operator
  - 9.3. To panic! or Not to panic!
    - Examples, Prototype Code, and Tests
    - When You Have More Information Than the Compiler
    - Guidelines for Error Handling
    - Custom Types for Validation
  - Summary
- 10. Generic Types, Traits, and Lifetimes
  - Removing Duplication by Extracting a Function
  - 10.1. Generic Data Types
    - In Function Definitions
    - In Struct Definitions
    - In Enum Definitions
    - In Method Definitions
    - Performance of Code Using Generics
  - 10.2. Defining Shared Behavior with Traits
    - Defining a Trait
    - Implementing a Trait on a Type
    - Using Default Implementations
    - Using Traits as Parameters
      - Trait Bound Syntax
      - Multiple Trait Bounds with the + Syntax
      - Clearer Trait Bounds with where Clauses
    - Returning Types That Implement Traits
    - Using Trait Bounds to Conditionally Implement Methods
  - 10.3. Validating References with Lifetimes
    - Dangling References
    - The Borrow Checker
    - Generic Lifetimes in Functions
    - Lifetime Annotation Syntax
    - In Function Signatures
    - Relationships
    - In Struct Definitions
    - Lifetime Elision
    - In Method Definitions
    - The Static Lifetime
  - Generic Type Parameters, Trait Bounds, and Lifetimes
  - Summary
- 11. Writing Automated Tests
  - 11.1. How to Write Tests
    - Structuring Test Functions
    - Checking Results with assert!
    - Testing Equality with assert_eq! and assert_ne!
    - Adding Custom Failure Messages
    - Checking for Panics with should_panic
    - Using Result<T, E> in Tests
  - 11.2. Controlling How Tests Are Run
    - Running Tests in Parallel or Consecutively
    - Showing Function Output
    - Running a Subset of Tests by Name
      - Running Single Tests
      - Filtering to Run Multiple Tests
    - Ignoring Tests Unless Specifically Requested
  - 11.3. Test Organization
    - Unit Tests
      - The tests Module and #[cfg(test)]
      - Private Function Tests
    - Integration Tests
      - The tests Directory
      - Submodules in Integration Tests
      - Integration Tests for Binary Crates
  - Summary
- 12. An I/O Project: Building a Command Line Program
  - 12.1. Accepting Command Line Arguments
    - Reading the Argument Values
    - The args Function and Invalid Unicode
    - Saving the Argument Values in Variables
  - 12.2. Reading a File
  - 12.3. Refactoring to Improve Modularity and Error Handling
    - Separating Concerns in Binary Projects
      - Extracting the Argument Parser
      - Grouping Configuration Values
    - The Trade-Offs of Using clone
      - Creating a Constructor for Config
    - Fixing the Error Handling
      - Improving the Error Message
      - Returning a Result Instead of Calling panic!
      - Calling Config::build and Handling Errors
    - Extracting Logic from main
      - Returning Errors from run
      - Handling Errors Returned from run in main
    - Splitting Code into a Library Crate
  - Adding Functionality with Test-Driven Development
    - Writing a Failing Test
    - Writing Code to Pass the Test
      - Iterating Through Lines with the lines Method
      - Searching Each Line for the Query
      - Storing Matching Lines
  - 12.5. Working with Environment Variables
    - Writing a Failing Test for Case-Insensitive Search
    - Implementing the search_case_insensitive Function
  - 12.6. Redirecting Errors to Standard Error
    - Checking Where Errors Are Written
    - Printing Errors to Standard Error
  - Summary
- 13. Functional Language Features: Iterators and Closures
  - 13.1. Closures
    - Capturing the Environment
    - Inferring and Annotating Closure Types
    - Capturing References or Moving Ownership
    - Moving Captured Values Out of Closures
  - 13.2. Processing a Series of Items with Iterators
    - The Iterator Trait and the next Method
    - Methods That Consume the Iterator
    - Methods That Produce Other Iterators
    - Closures That Capture Their Environment
  - 13.3. Improving Our I/O Project
    - Removing a clone Using an Iterator
      - Using the Returned Iterator Directly
      - Using Iterator Trait Methods
    - Clarifying Code with Iterator Adapters
    - Choosing Between Loops and Iterators
  - 13.4. Performance in Loops vs. Iterators
  - Summary
- More About Cargo and Crates.io
  - 14.1. Customizing Builds with Release Profiles
  - 14.2. Publishing a Crate to Crates.io
    - Making Useful Documentation Comments
      - Commonly Used Sections
      - Documentation Comments as Tests
      - Contained Item Comments
    - Exporting a Convenient Public API
    - Setting Up a Crates.io Account
    - Adding Metadata to a New Crate
    - Publishing to Crates.io
    - Publishing a New Version of an Existing Crate
    - Deprecating Versions from Crates.io
  - 14.3. Cargo Workspaces
    - Creating a Workspace
    - Creating the Second Package in the Workspace
    - Depending on an External Package
    - Adding a Test to a Workspace
  - 14.4. Installing Binaries with cargo install
  - 14.5. Extending Cargo with Custom Commands
  - Summary
- 15. Smart Pointers
  - 15.1. Using Box<T> to Point to Data on the Heap
    - Storing Data on the Heap
    - Enabling Recursive Types with Boxes
      - Understanding the Cons List
      - Computing the Size of a Non-Recursive Type
      - Getting a Recursive Type with a Known Size
  - 15.2. Treating Smart Pointers Like Regular References
    - Following the Reference to the Value
    - Using Box<T> Like a Reference
    - Defining Our Own Smart Pointer
    - Implementing the Deref Trait
    - Using Deref Coercion in Functions and Methods
    - Handling Deref Coercion with Mutable References
  - 15.3. Running Code on Cleanup with the Drop Trait
  - Rc<T> , the Reference-Counted Smart Pointer
    - Sharing Data
    - Cloning to Increase the Reference Count
  - 15.5. RefCell<T> and the Interior Mutability Pattern
    - Enforcing Borrowing Rules at Runtime
    - Using Interior Mutability
      - Testing with Mock Objects
      - Tracking Borrows at Runtime
    - Allowing Multiple Owners of Mutable Data
  - 15.6. Reference Cycles Can Leak Memory
    - Creating a Reference Cycle
    - Preventing Reference Cycles Using Weak<T>
      - Creating a Tree Data Structure
      - Adding a Reference from a Child to Its Parent
      - Visualizing Changes to strong_count and weak_count
  - Summary
- 16. Fearless Concurrency
  - 16.1. Using Threads to Run Code Simultaneously
    - Creating a New Thread with spawn
    - Waiting for All Threads to Finish
    - Using move Closures with Threads
  - 16.2. Transfer Data Between Threads with Message Passing
    - Transferring Ownership Through Channels
    - Sending Multiple Values
    - Creating Multiple Producers
  - 16.3. Shared-State Concurrency
    - Controlling Access with Mutexes
      - The API of Mutex<T>
      - Shared Access to Mutex<T>
      - Multiple Ownership with Multiple Threads
      - Atomic Reference Counting with Arc<T>
    - Comparing RefCell<T> / Rc<T> and Mutex<T> / Arc<T>
  - 16.4. Extensible Concurrency with Send and Sync
    - Transferring Ownership Between Threads
    - Accessing from Multiple Threads
    - Implementing Send and Sync Manually Is Unsafe
  - Summary
- 17. Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams
  - Parallelism and Concurrency
  - 17.1. Futures and the Async Syntax
  - Our First Async Program
    - Defining the page_title Function
    - Executing an Async Function with a Runtime
    - Racing Two URLs Against Each Other Concurrently
  - 17.2. Applying Concurrency with Async
    - Creating a New Task with spawn_task
    - Sending Data Between Two Tasks Using Message Passing
      - Code Within One Async Block Executes Linearly
      - Moving Ownership Into an Async Block
      - Joining a Number of Futures with the join! Macro
    - Yielding Control to the Runtime
    - Building Our Own Async Abstractions
  - 17.4. Streams: Futures in Sequence
  - 17.5. A Closer Look at the Traits for Async
    - The Future Trait
    - The Pin Type and the Unpin Trait
    - The Stream Trait
  - Putting It All Together: Futures, Tasks, and Threads
  - Summary
- Object-Oriented Programming Features
  - 18.1. Characteristics of Object-Oriented Languages
    - Objects Contain Data and Behavior
    - Encapsulation That Hides Implementation Details
    - Inheritance as a Type System and as Code Sharing
    - Polymorphism
  - 18.2. Using Trait Objects to Abstract over Shared Behavior
    - Defining a Trait for Common Behavior
    - Implementing the Trait
    - Performing Dynamic Dispatch
  - 18.3. Implementing an Object-Oriented Design Pattern
    - Attempting Traditional Object-Oriented Style
      - Defining Post and Creating a New Instance
      - Storing the Text of the Post Content
      - Ensuring That the Content of a Draft Post Is Empty
      - Requesting a Review, Which Changes the Post’s State
      - Adding approve to Change content ’s Behavior
    - Why Not An Enum?
      - Evaluating the State Pattern
    - Encoding States and Behavior as Types
  - Summary
- 19. Patterns and Matching
  - 19.1. All the Places Patterns Can Be Used
    - match Arms
    - let Statements
    - Conditional if let Expressions
    - while let Conditional Loops
    - for Loops
    - Function Parameters
  - 19.2. Refutability: Whether a Pattern Might Fail to Match
  - 19.3. Pattern Syntax
    - Matching Literals
    - Matching Named Variables
    - Matching Multiple Patterns
    - Matching Ranges of Values with ..=
    - Destructuring to Break Apart Values
      - Structs
      - Enums
      - Nested Structs and Enums
      - Structs and Tuples
    - Ignoring Values in a Pattern
      - An Entire Value with _
      - Parts of a Value with a Nested _
      - An Unused Variable by Starting Its Name with _
      - Remaining Parts of a Value with ..
    - Adding Conditionals with Match Guards
    - Using @ Bindings
  - Summary
- 20. Advanced Features
  - 20.1. Unsafe Rust
    - Performing Unsafe Superpowers
    - Dereferencing a Raw Pointer
    - Calling an Unsafe Function or Method
      - Creating a Safe Abstraction over Unsafe Code
      - Using extern Functions to Call External Code
      - Calling Rust Functions from Other Languages
    - Accessing or Modifying a Mutable Static Variable
    - Implementing an Unsafe Trait
    - Accessing Fields of a Union
    - Using Miri to Check Unsafe Code
    - Using Unsafe Code Correctly
  - 20.2. Advanced Traits
    - Defining Traits with Associated Types
    - Using Default Generic Parameters and Operator Overloading
    - Disambiguating Between Identically Named Methods
    - Using Supertraits
    - Implementing External Traits with the Newtype Pattern
  - 20.3. Advanced Types
    - Type Safety and Abstraction with the Newtype Pattern
    - Type Synonyms and Type Aliases
    - The Never Type That Never Returns
    - Dynamically Sized Types and the Sized Trait
  - 20.4. Advanced Functions and Closures
    - Function Pointers
    - Returning Closures
  - 20.5. Macros
    - The Difference Between Macros and Functions
    - Declarative Macros for General Metaprogramming
    - Procedural Macros for Generating Code from Attributes
    - Custom derive Macros
    - Attribute-Like Macros
    - Function-Like Macros
  - Summary
- 21. Final Project: Building a Multithreaded Web Server
  - 21.1. Building a Single-Threaded Web Server
    - Listening to the TCP Connection
    - Reading the Request
    - Looking More Closely at an HTTP Request
    - Writing a Response
    - Returning Real HTML
    - Validating the Request and Selectively Responding
    - Refactoring
  - From a Single-Threaded to a Multithreaded Server
    - Simulating a Slow Request
    - Improving Throughput with a Thread Pool
      - Spawning a Thread for Each Request
      - Creating a Finite Number of Threads
      - Building ThreadPool Using Compiler-Driven Development
      - Validating the Number of Threads in new
      - Creating Space to Store the Threads
      - Sending Code from the ThreadPool to a Thread
      - Sending Requests to Threads via Channels
      - Implementing the execute Method
  - 21.3. Graceful Shutdown and Cleanup
    - Implementing the Drop Trait on ThreadPool
    - Signaling to the Threads to Stop Listening for Jobs
  - Summary
- 22. Appendix
  - Appendix A: Keywords
    - Keywords Currently in Use
    - Keywords Reserved for Future Use
    - Raw Identifiers
  - Appendix B: Operators and Symbols
    - Operators
    - Non-operator Symbols
  - Appendix C: Derivable Traits
    - Debug for Programmer Output
    - PartialEq and Eq for Equality Comparisons
    - PartialOrd and Ord for Ordering Comparisons
    - Clone and Copy for Duplicating Values
    - Hash for Mapping a Value to a Value of Fixed Size
    - Default for Default Values
  - Appendix D: Useful Development Tools
    - Automatic Formatting with rustfmt
    - Fix Your Code with rustfix
    - More Lints with Clippy
    - IDE Integration Using rust-analyzer
  - Appendix E: Editions
  - Appendix F: Translations of the Book
  - Appendix G - How Rust is Made and “Nightly Rust”
    - Stability Without Stagnation
    - Choo, Choo! Release Channels and Riding the Trains
    - Maintenance time
    - Unstable Features
    - Rustup and the Role of Rust Nightly
    - The RFC Process and Teams
